# 问题记录

本来以为只要把mit课程的内容搬到这里就能正常运行了，但事实上远没有那么简单。事实上mit的课程是基于教学目的，所以不会在性能和设计上做太多的考究，并且很多地方是鼓励你使用多线程去简化整个代码设计(当然这也会带来很多并发场景的处理，但这也是官方希望的，因为这样也能更好的理解分布式系统上遇到的各种问题。比如消息延时，消息丢失，超时，乱序各种场景)。
然而tinykv的课程更多是让你实现一个etcd的工业化版本，从实现和理解上其实是会更难。在这里主要记录下实现过程遇到的各种疑惑和问题。

## RaftLog
RaftLog定义了一个stabled的东西，这个在mit6.824是没有的。
```go
//log entries with index <= stabled are persisted to storage.
```
这意味着raft log也并不是实时持久化的，先append到内存再批量flush。在mit的课程里面也有提到，如果每次写一个log都fsync到磁盘，从效率上看其实是非常低的。

[storage和unstable的关系](https://jishuin.proginn.com/p/763bfbd2eddb)

## StateMachine
在mit的课程上我们并行发送请求是通过go routine实现的，而且在接收各种请求的逻辑上实际上也是一个并发的过程。举个栗子，一个节点当前的term是2，这时候同时发生election timeout和收到一个term=4的心跳包，这两个操作都会对当前节点的term进行修改，我们就必须通过锁来对其进行限制来保证处理结果的正确性。
然而etcd的设计不一样，etcd把网络通讯、逻辑时钟都从raft的实现上剥离出来。所有这些会对raft状态造成变更的操作都抽象成事件，并且保证这种事件会串行到达一个raft node，用状态机的思路来驱动整个raft的状态变更。我理解这种修改会带来几个好处：
- 代码上更简洁(虽然会提高理解成本)
- 减少锁冲突(mit的课程data race的处理就很痛苦，还可能不小心就会造成一个dead lock)
- 方便测试，网络通讯的逻辑从raft的逻辑中剥离，测试就可以直接通过一个简单的step来模拟整个状态机的驱动
